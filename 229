using Microsoft.Data.Sqlite;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace Assembly3DCamera
{
    public static class DailyCsvExporter
    {
        public static void ExportDaily(SqliteConnection oConn, string tableName, string baseCsvPath,
                                       string dbKey)
        {
            string todayPath = Path.Combine(
                baseCsvPath,
                DateTime.Now.ToString("yyyy"),
                DateTime.Now.ToString("MM"),
                DateTime.Now.ToString("dd")
            );
            Directory.CreateDirectory(todayPath);

            string todayCpFile = Path.Combine(todayPath, $"{DateTime.Now:dd}checkpoints.txt");

            Dictionary<string, long> checkpoints = LoadDailyCheckpoints(todayCpFile, todayPath);

            string checkpointKey = dbKey + "|" + tableName;
            long lastRowId = checkpoints.ContainsKey(checkpointKey) ? checkpoints[checkpointKey] : 0;
            long newLast = lastRowId;

            string query = $"SELECT ROWID, * FROM \"{tableName}\" WHERE ROWID > {lastRowId};";

            using (var cmd = oConn.CreateCommand())
            {
                cmd.CommandText = query;
                using (var reader = cmd.ExecuteReader())
                {
                    if (!reader.HasRows) return;

                    string csvFile = Path.Combine(todayPath, $"{SanitizeFileName(tableName)}.csv");
                    bool writeHeader = !File.Exists(csvFile);

                    using (var writer = new StreamWriter(csvFile, true, Encoding.UTF8))
                    {
                        int cols = reader.FieldCount;

                        if (writeHeader)
                        {
                            for (int i = 1; i < cols; i++)
                            {
                                if (i > 1) writer.Write(",");
                                writer.Write(EscapeCsv(reader.GetName(i)));
                            }
                            writer.WriteLine();
                        }

                        int rowCount = 0;
                        while (reader.Read())
                        {
                            newLast = reader.GetInt64(0);
                            for (int i = 1; i < cols; i++)
                            {
                                if (i > 1) writer.Write(",");
                                writer.Write(reader.IsDBNull(i) ? "" : EscapeCsv(reader.GetValue(i).ToString()));
                            }
                            writer.WriteLine();
                            rowCount++;
                        }

                        if (rowCount > 0)
                        {
                            checkpoints[checkpointKey] = newLast;
                            SaveCheckpoints(todayCpFile, checkpoints);

                            Console.WriteLine($"[{DateTime.Now}] Exported {rowCount} rows from '{tableName}' to {csvFile}");
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Loads today's checkpoints, or if missing, searches backwards until it finds the most recent available file.
        /// </summary>
        private static Dictionary<string, long> LoadDailyCheckpoints(string todayCpFile, string todayPath)
        {
            if (File.Exists(todayCpFile))
                return LoadCheckpoints(todayCpFile);

            DateTime probeDay = DateTime.Now.AddDays(-1);

            while (probeDay.Year >= 2000) // safe lower bound
            {
                string probePath = Path.Combine(
                    Path.GetDirectoryName(Path.GetDirectoryName(Path.GetDirectoryName(todayPath))),
                    probeDay.ToString("yyyy"),
                    probeDay.ToString("MM"),
                    probeDay.ToString("dd")
                );

                string probeCpFile = Path.Combine(probePath, $"{probeDay:dd}checkpoints.txt");

                if (File.Exists(probeCpFile))
                {
                    Console.WriteLine($"[{DateTime.Now}] No checkpoints for today, using last available from {probeDay:yyyy-MM-dd}");
                    return LoadCheckpoints(probeCpFile);
                }

                probeDay = probeDay.AddDays(-1);
            }

            // Nothing found at all
            return new Dictionary<string, long>();
        }

        private static Dictionary<string, long> LoadCheckpoints(string checkpointFile)
        {
            var dict = new Dictionary<string, long>();
            foreach (var line in File.ReadAllLines(checkpointFile))
            {
                if (string.IsNullOrWhiteSpace(line)) continue;
                int idx = line.LastIndexOf('|');
                if (idx <= 0) continue;

                string key = line.Substring(0, idx);
                string valStr = line.Substring(idx + 1);
                if (long.TryParse(valStr, out long val))
                    dict[key] = val;
            }
            return dict;
        }

        private static void SaveCheckpoints(string checkpointFile, Dictionary<string, long> checkpoints)
        {
            var lines = new List<string>();
            foreach (var kv in checkpoints)
                lines.Add(kv.Key + "|" + kv.Value);
            File.WriteAllLines(checkpointFile, lines);
        }

        private static string EscapeCsv(string val)
        {
            if (val == null) return "";
            bool mustQuote = val.Contains(",") || val.Contains("\"") || val.Contains("\n") || val.Contains("\r");
            if (val.Contains("\"")) val = val.Replace("\"", "\"\"");
            return mustQuote ? $"\"{val}\"" : val;
        }

        private static string SanitizeFileName(string name)
        {
            var invalid = Path.GetInvalidFileNameChars();
            var sb = new StringBuilder();
            foreach (var c in name)
                sb.Append(invalid.Contains(c) ? '_' : c);
            return sb.ToString();
        }
    }
}