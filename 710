{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "Nanonets": {
    "ApiKey": "YOUR_API_KEY_HERE",
    "ModelId": "YOUR_MODEL_ID_HERE"
  }
}


-----


namespace NanonetsExtractor.Models
{
    public class ExtractedData
    {
        public string FieldName { get; set; }
        public string Value { get; set; }
    }
}


-----



using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Configuration;
using NanonetsExtractor.Models;
using System.IO;
using System.Net.Http.Headers;
using System.Text;
using ClosedXML.Excel; // (optional for Excel export)
using System.Net.Http;

namespace NanonetsExtractor.Controllers
{
    public class HomeController : Controller
    {
        private readonly string _apiKey;
        private readonly string _modelId;
        private readonly IWebHostEnvironment _env;

        public HomeController(IConfiguration config, IWebHostEnvironment env)
        {
            _apiKey = config["Nanonets:ApiKey"];
            _modelId = config["Nanonets:ModelId"];
            _env = env;
        }

        public IActionResult Index()
        {
            return View();
        }

        [HttpPost]
        public async Task<IActionResult> UploadFile(IFormFile file)
        {
            if (file == null || file.Length == 0)
            {
                ViewBag.Message = "Please upload a valid file.";
                return View("Index");
            }

            string uploads = Path.Combine(_env.WebRootPath, "uploads");
            if (!Directory.Exists(uploads)) Directory.CreateDirectory(uploads);

            string filePath = Path.Combine(uploads, file.FileName);
            using (var stream = new FileStream(filePath, FileMode.Create))
            {
                await file.CopyToAsync(stream);
            }

            ViewBag.FilePath = filePath;
            ViewBag.ShowProcessButton = true;
            return View("Index");
        }

        [HttpPost]
        public async Task<IActionResult> ProcessFile(string filePath)
        {
            var data = await ExtractDataFromNanonets(filePath);
            TempData["ExtractedData"] = System.Text.Json.JsonSerializer.Serialize(data);
            return RedirectToAction("EditData");
        }

        public IActionResult EditData()
        {
            var json = TempData["ExtractedData"] as string;
            if (json == null) return RedirectToAction("Index");
            var data = System.Text.Json.JsonSerializer.Deserialize<List<ExtractedData>>(json);
            TempData.Keep("ExtractedData");
            return View(data);
        }

        [HttpPost]
        public IActionResult ConfirmChanges(List<ExtractedData> data)
        {
            TempData["FinalData"] = System.Text.Json.JsonSerializer.Serialize(data);
            return RedirectToAction("DownloadOptions");
        }

        public IActionResult DownloadOptions() => View();

        [HttpPost]
        public IActionResult Download(string format)
        {
            var json = TempData["FinalData"] as string;
            if (json == null) return RedirectToAction("Index");
            var data = System.Text.Json.JsonSerializer.Deserialize<List<ExtractedData>>(json);
            var fileName = $"ExtractedData_{DateTime.Now:yyyyMMddHHmmss}";

            return format switch
            {
                "csv" => File(GenerateCsv(data), "text/csv", fileName + ".csv"),
                "excel" => File(GenerateExcel(data), "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", fileName + ".xlsx"),
                "pdf" => File(GeneratePdf(data), "application/pdf", fileName + ".pdf"),
                _ => RedirectToAction("Index")
            };
        }

        private async Task<List<ExtractedData>> ExtractDataFromNanonets(string filePath)
        {
            var list = new List<ExtractedData>();
            using var client = new HttpClient();
            var byteArray = Encoding.ASCII.GetBytes(_apiKey + ":");
            client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Basic", Convert.ToBase64String(byteArray));

            using var form = new MultipartFormDataContent();
            form.Add(new StreamContent(System.IO.File.OpenRead(filePath)), "file", Path.GetFileName(filePath));

            var res = await client.PostAsync($"https://app.nanonets.com/api/v2/OCR/Model/{_modelId}/LabelFile/", form);
            var json = await res.Content.ReadAsStringAsync();

            // Parse roughly without Newtonsoft
            var parts = json.Split(new[] { "\"field_name\"", "\"text\"" }, StringSplitOptions.None);
            for (int i = 1; i < parts.Length - 1; i += 2)
            {
                string field = ExtractValue(parts[i]);
                string value = ExtractValue(parts[i + 1]);
                if (!string.IsNullOrEmpty(field))
                    list.Add(new ExtractedData { FieldName = field, Value = value });
            }
            return list;
        }

        private string ExtractValue(string input)
        {
            int start = input.IndexOf(":") + 2;
            int end = input.IndexOf("\"", start);
            if (start > 1 && end > start)
                return input.Substring(start, end - start);
            return string.Empty;
        }

        private byte[] GenerateCsv(List<ExtractedData> data)
        {
            var sb = new StringBuilder();
            sb.AppendLine("FieldName,Value");
            foreach (var d in data)
                sb.AppendLine($"{d.FieldName},{d.Value}");
            return Encoding.UTF8.GetBytes(sb.ToString());
        }

        private byte[] GenerateExcel(List<ExtractedData> data)
        {
            using var wb = new XLWorkbook();
            var ws = wb.Worksheets.Add("ExtractedData");
            ws.Cell(1, 1).Value = "Field Name";
            ws.Cell(1, 2).Value = "Value";

            for (int i = 0; i < data.Count; i++)
            {
                ws.Cell(i + 2, 1).Value = data[i].FieldName;
                ws.Cell(i + 2, 2).Value = data[i].Value;
            }

            using var ms = new MemoryStream();
            wb.SaveAs(ms);
            return ms.ToArray();
        }

        private byte[] GeneratePdf(List<ExtractedData> data)
        {
            var sb = new StringBuilder();
            sb.AppendLine("Extracted Data\n\n");
            foreach (var d in data)
                sb.AppendLine($"{d.FieldName}: {d.Value}");
            return Encoding.UTF8.GetBytes(sb.ToString());
        }
    }
}



------

@{
    ViewData["Title"] = "Upload Document";
}

<h2>Upload Document</h2>

<form method="post" enctype="multipart/form-data" asp-action="UploadFile">
    <input type="file" name="file" required />
    <button type="submit">Upload</button>
</form>

@if (ViewBag.ShowProcessButton != null)
{
    <hr />
    <form method="post" asp-action="ProcessFile">
        <input type="hidden" name="filePath" value="@ViewBag.FilePath" />
        <button type="submit">Process File</button>
    </form>
}



-------



@model List<NanonetsExtractor.Models.ExtractedData>

<h2>Edit Extracted Data</h2>

<form method="post" asp-action="ConfirmChanges">
<table border="1" cellpadding="5">
<tr><th>Field Name</th><th>Value</th></tr>
@for (int i = 0; i < Model.Count; i++)
{
    <tr>
        <td><input type="text" name="[@i].FieldName" value="@Model[i].FieldName" readonly /></td>
        <td><input type="text" name="[@i].Value" value="@Model[i].Value" /></td>
    </tr>
}
</table>
<br />
<button type="submit">Confirm Changes</button>
</form>



------



<h2>Download Extracted Report</h2>

<form method="post" asp-action="Download">
    <select name="format" required>
        <option value="pdf">PDF</option>
        <option value="csv">CSV</option>
        <option value="excel">Excel</option>
    </select>
    <button type="submit">Download</button>
</form>


------






using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Configuration;
using NanonetsExtractor.Models;
using System.IO;
using System.Net.Http.Headers;
using System.Text;
using ClosedXML.Excel; // optional
using System.Net.Http;
using System.Text.Json;

namespace NanonetsExtractor.Controllers
{
    public class HomeController : Controller
    {
        private readonly string _apiKey;
        private readonly string _modelId;
        private readonly IWebHostEnvironment _env;

        public HomeController(IConfiguration config, IWebHostEnvironment env)
        {
            _apiKey = config["Nanonets:ApiKey"];
            _modelId = config["Nanonets:ModelId"];
            _env = env;
        }

        public IActionResult Index()
        {
            return View();
        }

        [HttpPost]
        public async Task<IActionResult> UploadFile(IFormFile file)
        {
            if (file == null || file.Length == 0)
            {
                ViewBag.Message = "Please upload a valid file.";
                return View("Index");
            }

            // Save file
            string uploads = Path.Combine(_env.WebRootPath, "uploads");
            if (!Directory.Exists(uploads)) Directory.CreateDirectory(uploads);

            string savedPath = Path.Combine(uploads, Path.GetFileName(file.FileName));
            using (var stream = new FileStream(savedPath, FileMode.Create))
            {
                await file.CopyToAsync(stream);
            }

            // Pass file name (not full path) to view
            ViewBag.FileName = Path.GetFileName(file.FileName);
            ViewBag.ShowProcessButton = true;
            return View("Index");
        }

        [HttpPost]
        public async Task<IActionResult> ProcessFile(string fileName)
        {
            if (string.IsNullOrEmpty(fileName))
            {
                ViewBag.Message = "File not found.";
                return RedirectToAction("Index");
            }

            string filePath = Path.Combine(_env.WebRootPath, "uploads", fileName);
            if (!System.IO.File.Exists(filePath))
            {
                ViewBag.Message = "File not found on server.";
                return RedirectToAction("Index");
            }

            var extractedData = await ExtractDataFromNanonets(filePath);
            TempData["ExtractedData"] = JsonSerializer.Serialize(extractedData);
            return RedirectToAction("EditData");
        }

        public IActionResult EditData()
        {
            if (!TempData.ContainsKey("ExtractedData"))
                return RedirectToAction("Index");

            var data = JsonSerializer.Deserialize<List<ExtractedData>>(TempData["ExtractedData"] as string);
            TempData.Keep("ExtractedData");
            return View(data);
        }

        [HttpPost]
        public IActionResult ConfirmChanges(List<ExtractedData> data)
        {
            TempData["FinalData"] = JsonSerializer.Serialize(data);
            return RedirectToAction("DownloadOptions");
        }

        public IActionResult DownloadOptions() => View();

        [HttpPost]
        public IActionResult Download(string format)
        {
            if (!TempData.ContainsKey("FinalData"))
                return RedirectToAction("Index");

            var data = JsonSerializer.Deserialize<List<ExtractedData>>(TempData["FinalData"] as string);
            var fileName = $"ExtractedData_{DateTime.Now:yyyyMMddHHmmss}";

            return format switch
            {
                "csv" => File(GenerateCsv(data), "text/csv", fileName + ".csv"),
                "excel" => File(GenerateExcel(data), "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", fileName + ".xlsx"),
                "pdf" => File(GeneratePdf(data), "application/pdf", fileName + ".pdf"),
                _ => RedirectToAction("Index")
            };
        }

        private async Task<List<ExtractedData>> ExtractDataFromNanonets(string filePath)
        {
            var results = new List<ExtractedData>();

            using var client = new HttpClient();
            var byteArray = Encoding.ASCII.GetBytes(_apiKey + ":");
            client.DefaultRequestHeaders.Authorization =
                new AuthenticationHeaderValue("Basic", Convert.ToBase64String(byteArray));

            using var form = new MultipartFormDataContent();
            form.Add(new StreamContent(System.IO.File.OpenRead(filePath)), "file", Path.GetFileName(filePath));

            var response = await client.PostAsync($"https://app.nanonets.com/api/v2/OCR/Model/{_modelId}/LabelFile/", form);
            var json = await response.Content.ReadAsStringAsync();

            // Rough parsing
            var items = json.Split(new[] { "\"field_name\"", "\"text\"" }, StringSplitOptions.None);
            for (int i = 1; i < items.Length - 1; i += 2)
            {
                string field = ExtractValue(items[i]);
                string value = ExtractValue(items[i + 1]);
                if (!string.IsNullOrEmpty(field))
                    results.Add(new ExtractedData { FieldName = field, Value = value });
            }

            return results;
        }

        private string ExtractValue(string input)
        {
            int start = input.IndexOf(":") + 2;
            int end = input.IndexOf("\"", start);
            if (start > 1 && end > start)
                return input.Substring(start, end - start);
            return string.Empty;
        }

        private byte[] GenerateCsv(List<ExtractedData> data)
        {
            var sb = new StringBuilder();
            sb.AppendLine("FieldName,Value");
            foreach (var d in data)
                sb.AppendLine($"{d.FieldName},{d.Value}");
            return Encoding.UTF8.GetBytes(sb.ToString());
        }

        private byte[] GenerateExcel(List<ExtractedData> data)
        {
            using var wb = new XLWorkbook();
            var ws = wb.Worksheets.Add("ExtractedData");
            ws.Cell(1, 1).Value = "Field Name";
            ws.Cell(1, 2).Value = "Value";
            for (int i = 0; i < data.Count; i++)
            {
                ws.Cell(i + 2, 1).Value = data[i].FieldName;
                ws.Cell(i + 2, 2).Value = data[i].Value;
            }
            using var ms = new MemoryStream();
            wb.SaveAs(ms);
            return ms.ToArray();
        }

        private byte[] GeneratePdf(List<ExtractedData> data)
        {
            var sb = new StringBuilder();
            sb.AppendLine("Extracted Data\n\n");
            foreach (var d in data)
                sb.AppendLine($"{d.FieldName}: {d.Value}");
            return Encoding.UTF8.GetBytes(sb.ToString());
        }
    }
}



-----------




@{
    ViewData["Title"] = "Upload Document";
}

<h2>Upload Document</h2>

<form method="post" enctype="multipart/form-data" asp-action="UploadFile">
    <input type="file" name="file" required />
    <button type="submit">Upload</button>
</form>

@if (ViewBag.ShowProcessButton != null)
{
    <hr />
    <form method="post" asp-action="ProcessFile">
        <input type="hidden" name="fileName" value="@ViewBag.FileName" />
        <button type="submit">Process File</button>
    </form>
}





-----------


@model List<NanonetsExtractor.Models.ExtractedData>

<h2>Edit Extracted Data</h2>

<form method="post" asp-action="ConfirmChanges">
    <table border="1" cellpadding="5">
        <tr><th>Field Name</th><th>Value</th></tr>
        @for (int i = 0; i < Model.Count; i++)
        {
            <tr>
                <td><input type="text" name="[@i].FieldName" value="@Model[i].FieldName" readonly /></td>
                <td><input type="text" name="[@i].Value" value="@Model[i].Value" /></td>
            </tr>
        }
    </table>
    <br />
    <button type="submit">Confirm Changes</button>
</form>




----------



<h2>Download Extracted Report</h2>

<form method="post" asp-action="Download">
    <select name="format" required>
        <option value="pdf">PDF</option>
        <option value="csv">CSV</option>
        <option value="excel">Excel</option>
    </select>
    <button type="submit">Download</button>
</form>


--------


using Microsoft.AspNetCore.Mvc;
using System.Net.Http.Headers;
using System.Text.Json;

namespace NanonetsApp.Controllers
{
    public class HomeController : Controller
    {
        private readonly IWebHostEnvironment _env;
        private readonly string _apiKey = "YOUR_API_KEY";
        private readonly string _modelId = "YOUR_MODEL_ID";

        public HomeController(IWebHostEnvironment env)
        {
            _env = env;
        }

        public IActionResult Index()
        {
            return View();
        }

        [HttpPost]
        public async Task<IActionResult> Upload(IFormFile file)
        {
            if (file == null || file.Length == 0)
                return Json(new { success = false, message = "No file uploaded" });

            var uploads = Path.Combine(_env.WebRootPath, "uploads");
            if (!Directory.Exists(uploads))
                Directory.CreateDirectory(uploads);

            var filePath = Path.Combine(uploads, file.FileName);
            using (var stream = new FileStream(filePath, FileMode.Create))
            {
                await file.CopyToAsync(stream);
            }

            TempData["UploadedFilePath"] = filePath;
            return Json(new { success = true });
        }

        [HttpPost]
        public async Task<IActionResult> ProcessFile()
        {
            string? filePath = TempData["UploadedFilePath"] as string;
            if (string.IsNullOrEmpty(filePath))
                return Json(new { success = false, message = "File not found." });

            using var httpClient = new HttpClient();
            httpClient.DefaultRequestHeaders.Authorization =
                new AuthenticationHeaderValue("Basic",
                    Convert.ToBase64String(System.Text.Encoding.ASCII.GetBytes($"{_apiKey}:")));

            var form = new MultipartFormDataContent();
            var fileBytes = await System.IO.File.ReadAllBytesAsync(filePath);
            form.Add(new ByteArrayContent(fileBytes), "file", Path.GetFileName(filePath));

            var response = await httpClient.PostAsync($"https://app.nanonets.com/api/v2/OCR/Model/{_modelId}/LabelFile/", form);
            var result = await response.Content.ReadAsStringAsync();

            if (!response.IsSuccessStatusCode)
                return Json(new { success = false, message = "Processing failed." });

            var json = JsonSerializer.Deserialize<JsonElement>(result);
            return Json(new { success = true, data = json });
        }
    }
}


---------

@{
    ViewData["Title"] = "Document Processor";
}

<div style="text-align:center; margin-top:50px;">
    <h2>Upload a Document</h2>

    <input type="file" id="fileInput" class="form-control" style="width:300px; margin:auto;">
    <button id="uploadBtn" class="btn btn-primary mt-3">Upload</button>

    <div id="processDiv" style="display:none; margin-top:20px;">
        <button id="processBtn" class="btn btn-success">Process File</button>
    </div>

    <div id="loading" style="display:none; margin-top:20px;">Processing... Please wait</div>

    <div id="resultDiv" style="display:none; margin-top:20px;"></div>
</div>

<script>
document.getElementById("uploadBtn").addEventListener("click", async () => {
    const fileInput = document.getElementById("fileInput");
    const file = fileInput.files[0];
    if (!file) {
        alert("Please select a file first.");
        return;
    }

    const formData = new FormData();
    formData.append("file", file);

    const response = await fetch("/Home/Upload", { method: "POST", body: formData });
    const result = await response.json();

    if (result.success) {
        alert("File uploaded successfully!");
        document.getElementById("processDiv").style.display = "block";
    } else {
        alert(result.message);
    }
});

document.getElementById("processBtn").addEventListener("click", async () => {
    document.getElementById("loading").style.display = "block";

    const response = await fetch("/Home/ProcessFile", { method: "POST" });
    const result = await response.json();

    document.getElementById("loading").style.display = "none";

    if (result.success) {
        document.getElementById("resultDiv").style.display = "block";
        document.getElementById("resultDiv").innerHTML =
            "<pre>" + JSON.stringify(result.data, null, 2) + "</pre>";
    } else {
        alert(result.message);
    }
});
</script>



------

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddControllersWithViews();

var app = builder.Build();

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Home/Error");
}

app.UseStaticFiles();
app.UseRouting();
app.UseAuthorization();

app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");

app.Run();



-----


@{
    ViewData["Title"] = "Document Processor";
}

<div style="text-align:center; margin-top:40px;">
    <h2>Upload a Document</h2>

    <input type="file" id="fileInput" class="form-control" style="width:300px; margin:auto;">
    <button id="uploadBtn" class="btn btn-primary mt-3">Upload</button>

    <div id="processDiv" style="display:none; margin-top:20px;">
    <button id="processBtn" class="btn btn-success">Process File</button>
    </div>

    <div id="loading" style="display:none; margin-top:20px;">Processing... Please wait</div>

    <div id="resultDiv" style="margin-top:30px;"></div>

    <div id="buttonsDiv" style="display:none; margin-top:20px;">
        <button class="btn btn-info" id="downloadCsv">Download CSV</button>
        <button classâ€”"btn btn-info" id="downloadExcel">Download Excel</button>
        <button class="btn btn-info" id="downloadPdf">Download PDF</button>
    </div>
</div>

<script>
let extractedData = [];

document.getgElementById("uploadBtn").addListensener("click", async () => {
    const fileInput = document.getgElementById("fileInput");
    const file = fileInput.files[0];
    if (!file) { alert("Please select a file"); return; }

    const formData = new FormData();
    formData.append("file", file);

    const res = await fetch("/Home/Upload", { method: "POST", body: formData });
    const result = await res.json();
    if (result.success) {
        alert("File uploaded successfully!");
        document.getElementById("processDiv").style.display = "block";
    } else { alert(result.message); }
});

document.getgElementById("processBtn").addListensener("click", async () => {
    document.getgElementById("loading").style.display = "block";

    const response = await fetch("/Home/ProcessFile", { method: "POST" });
    const result = await response.json();
    document.getgElementById("loading").style.display = "none";

    if (result.success) {
        const predictions = result.data.result[0].prediction;
        extractedData = predictions.map(p => ({
            label: p.label,
    text: p.ocr_text
        }));
        renderTable();
        document.getgElementById("buttonsDiv").style.display = "block";
    } else { alert(result.message); }
});

function renderTable() {
    let html = "<table class='table table-bordered' style='margin:auto; width:70%;'>";
    html += "<tr><th>Label</th><th>Value</th></tr>";
    extractedData.forEach((item, idx) => {
        html += `<tr>
            <td>${item.label}</td>
            <td contenteditable='true' oninput='updateValue(${idx}, this)'>${item.text}</td>
        </tr>`;
    });
    html += "</table>";
    document.getgElementById("resultDiv").innerHTML = html;
}

function updateValue(idx, el) {
    extractedData[idx].text = el.innerText;
}

// Download handlers
function downloadFile(data, type, filename) {
    const blob = new Blob([data], { type: type });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = filename; a.click();
    URL.revokeObjectURL(url);
}

document.getgElementById("downloadCsv").addListensener("click", () => {
    let csv = "Label,Value\n" + extractedData.map(x => `${x.label},${x.text}`).join("\n");
    downloadFile(csv, "text/csv", "extracted_data.csv");
});

document.getgElementById("downloadExcel").addListensener("click", () => {
    let tsv = "Label\tValue\n" + extractedData.map(x => `${x.label}\t${x.text}`).join("\n");
    downloadFile(tsv, "application/vnd.ms-excel", "extracted_data.xls");
});

document.getgElementById("downloadPdf").addListensener("click", () => {
    const content = extractedData.map(x => `${x.label}: ${x.text}`).join("\n");
    downloadFile(content, "application/pdf", "extracted_data.pdf");
});
</script>

