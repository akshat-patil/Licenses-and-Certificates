{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "Nanonets": {
    "ApiKey": "YOUR_API_KEY_HERE",
    "ModelId": "YOUR_MODEL_ID_HERE"
  }
}


-----


namespace NanonetsExtractor.Models
{
    public class ExtractedData
    {
        public string FieldName { get; set; }
        public string Value { get; set; }
    }
}


-----



using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Configuration;
using NanonetsExtractor.Models;
using System.IO;
using System.Net.Http.Headers;
using System.Text;
using ClosedXML.Excel; // (optional for Excel export)
using System.Net.Http;

namespace NanonetsExtractor.Controllers
{
    public class HomeController : Controller
    {
        private readonly string _apiKey;
        private readonly string _modelId;
        private readonly IWebHostEnvironment _env;

        public HomeController(IConfiguration config, IWebHostEnvironment env)
        {
            _apiKey = config["Nanonets:ApiKey"];
            _modelId = config["Nanonets:ModelId"];
            _env = env;
        }

        public IActionResult Index()
        {
            return View();
        }

        [HttpPost]
        public async Task<IActionResult> UploadFile(IFormFile file)
        {
            if (file == null || file.Length == 0)
            {
                ViewBag.Message = "Please upload a valid file.";
                return View("Index");
            }

            string uploads = Path.Combine(_env.WebRootPath, "uploads");
            if (!Directory.Exists(uploads)) Directory.CreateDirectory(uploads);

            string filePath = Path.Combine(uploads, file.FileName);
            using (var stream = new FileStream(filePath, FileMode.Create))
            {
                await file.CopyToAsync(stream);
            }

            ViewBag.FilePath = filePath;
            ViewBag.ShowProcessButton = true;
            return View("Index");
        }

        [HttpPost]
        public async Task<IActionResult> ProcessFile(string filePath)
        {
            var data = await ExtractDataFromNanonets(filePath);
            TempData["ExtractedData"] = System.Text.Json.JsonSerializer.Serialize(data);
            return RedirectToAction("EditData");
        }

        public IActionResult EditData()
        {
            var json = TempData["ExtractedData"] as string;
            if (json == null) return RedirectToAction("Index");
            var data = System.Text.Json.JsonSerializer.Deserialize<List<ExtractedData>>(json);
            TempData.Keep("ExtractedData");
            return View(data);
        }

        [HttpPost]
        public IActionResult ConfirmChanges(List<ExtractedData> data)
        {
            TempData["FinalData"] = System.Text.Json.JsonSerializer.Serialize(data);
            return RedirectToAction("DownloadOptions");
        }

        public IActionResult DownloadOptions() => View();

        [HttpPost]
        public IActionResult Download(string format)
        {
            var json = TempData["FinalData"] as string;
            if (json == null) return RedirectToAction("Index");
            var data = System.Text.Json.JsonSerializer.Deserialize<List<ExtractedData>>(json);
            var fileName = $"ExtractedData_{DateTime.Now:yyyyMMddHHmmss}";

            return format switch
            {
                "csv" => File(GenerateCsv(data), "text/csv", fileName + ".csv"),
                "excel" => File(GenerateExcel(data), "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", fileName + ".xlsx"),
                "pdf" => File(GeneratePdf(data), "application/pdf", fileName + ".pdf"),
                _ => RedirectToAction("Index")
            };
        }

        private async Task<List<ExtractedData>> ExtractDataFromNanonets(string filePath)
        {
            var list = new List<ExtractedData>();
            using var client = new HttpClient();
            var byteArray = Encoding.ASCII.GetBytes(_apiKey + ":");
            client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Basic", Convert.ToBase64String(byteArray));

            using var form = new MultipartFormDataContent();
            form.Add(new StreamContent(System.IO.File.OpenRead(filePath)), "file", Path.GetFileName(filePath));

            var res = await client.PostAsync($"https://app.nanonets.com/api/v2/OCR/Model/{_modelId}/LabelFile/", form);
            var json = await res.Content.ReadAsStringAsync();

            // Parse roughly without Newtonsoft
            var parts = json.Split(new[] { "\"field_name\"", "\"text\"" }, StringSplitOptions.None);
            for (int i = 1; i < parts.Length - 1; i += 2)
            {
                string field = ExtractValue(parts[i]);
                string value = ExtractValue(parts[i + 1]);
                if (!string.IsNullOrEmpty(field))
                    list.Add(new ExtractedData { FieldName = field, Value = value });
            }
            return list;
        }

        private string ExtractValue(string input)
        {
            int start = input.IndexOf(":") + 2;
            int end = input.IndexOf("\"", start);
            if (start > 1 && end > start)
                return input.Substring(start, end - start);
            return string.Empty;
        }

        private byte[] GenerateCsv(List<ExtractedData> data)
        {
            var sb = new StringBuilder();
            sb.AppendLine("FieldName,Value");
            foreach (var d in data)
                sb.AppendLine($"{d.FieldName},{d.Value}");
            return Encoding.UTF8.GetBytes(sb.ToString());
        }

        private byte[] GenerateExcel(List<ExtractedData> data)
        {
            using var wb = new XLWorkbook();
            var ws = wb.Worksheets.Add("ExtractedData");
            ws.Cell(1, 1).Value = "Field Name";
            ws.Cell(1, 2).Value = "Value";

            for (int i = 0; i < data.Count; i++)
            {
                ws.Cell(i + 2, 1).Value = data[i].FieldName;
                ws.Cell(i + 2, 2).Value = data[i].Value;
            }

            using var ms = new MemoryStream();
            wb.SaveAs(ms);
            return ms.ToArray();
        }

        private byte[] GeneratePdf(List<ExtractedData> data)
        {
            var sb = new StringBuilder();
            sb.AppendLine("Extracted Data\n\n");
            foreach (var d in data)
                sb.AppendLine($"{d.FieldName}: {d.Value}");
            return Encoding.UTF8.GetBytes(sb.ToString());
        }
    }
}



------

@{
    ViewData["Title"] = "Upload Document";
}

<h2>Upload Document</h2>

<form method="post" enctype="multipart/form-data" asp-action="UploadFile">
    <input type="file" name="file" required />
    <button type="submit">Upload</button>
</form>

@if (ViewBag.ShowProcessButton != null)
{
    <hr />
    <form method="post" asp-action="ProcessFile">
        <input type="hidden" name="filePath" value="@ViewBag.FilePath" />
        <button type="submit">Process File</button>
    </form>
}



-------



@model List<NanonetsExtractor.Models.ExtractedData>

<h2>Edit Extracted Data</h2>

<form method="post" asp-action="ConfirmChanges">
<table border="1" cellpadding="5">
<tr><th>Field Name</th><th>Value</th></tr>
@for (int i = 0; i < Model.Count; i++)
{
    <tr>
        <td><input type="text" name="[@i].FieldName" value="@Model[i].FieldName" readonly /></td>
        <td><input type="text" name="[@i].Value" value="@Model[i].Value" /></td>
    </tr>
}
</table>
<br />
<button type="submit">Confirm Changes</button>
</form>



------



<h2>Download Extracted Report</h2>

<form method="post" asp-action="Download">
    <select name="format" required>
        <option value="pdf">PDF</option>
        <option value="csv">CSV</option>
        <option value="excel">Excel</option>
    </select>
    <button type="submit">Download</button>
</form>


------






using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Configuration;
using NanonetsExtractor.Models;
using System.IO;
using System.Net.Http.Headers;
using System.Text;
using ClosedXML.Excel; // optional
using System.Net.Http;
using System.Text.Json;

namespace NanonetsExtractor.Controllers
{
    public class HomeController : Controller
    {
        private readonly string _apiKey;
        private readonly string _modelId;
        private readonly IWebHostEnvironment _env;

        public HomeController(IConfiguration config, IWebHostEnvironment env)
        {
            _apiKey = config["Nanonets:ApiKey"];
            _modelId = config["Nanonets:ModelId"];
            _env = env;
        }

        public IActionResult Index()
        {
            return View();
        }

        [HttpPost]
        public async Task<IActionResult> UploadFile(IFormFile file)
        {
            if (file == null || file.Length == 0)
            {
                ViewBag.Message = "Please upload a valid file.";
                return View("Index");
            }

            // Save file
            string uploads = Path.Combine(_env.WebRootPath, "uploads");
            if (!Directory.Exists(uploads)) Directory.CreateDirectory(uploads);

            string savedPath = Path.Combine(uploads, Path.GetFileName(file.FileName));
            using (var stream = new FileStream(savedPath, FileMode.Create))
            {
                await file.CopyToAsync(stream);
            }

            // Pass file name (not full path) to view
            ViewBag.FileName = Path.GetFileName(file.FileName);
            ViewBag.ShowProcessButton = true;
            return View("Index");
        }

        [HttpPost]
        public async Task<IActionResult> ProcessFile(string fileName)
        {
            if (string.IsNullOrEmpty(fileName))
            {
                ViewBag.Message = "File not found.";
                return RedirectToAction("Index");
            }

            string filePath = Path.Combine(_env.WebRootPath, "uploads", fileName);
            if (!System.IO.File.Exists(filePath))
            {
                ViewBag.Message = "File not found on server.";
                return RedirectToAction("Index");
            }

            var extractedData = await ExtractDataFromNanonets(filePath);
            TempData["ExtractedData"] = JsonSerializer.Serialize(extractedData);
            return RedirectToAction("EditData");
        }

        public IActionResult EditData()
        {
            if (!TempData.ContainsKey("ExtractedData"))
                return RedirectToAction("Index");

            var data = JsonSerializer.Deserialize<List<ExtractedData>>(TempData["ExtractedData"] as string);
            TempData.Keep("ExtractedData");
            return View(data);
        }

        [HttpPost]
        public IActionResult ConfirmChanges(List<ExtractedData> data)
        {
            TempData["FinalData"] = JsonSerializer.Serialize(data);
            return RedirectToAction("DownloadOptions");
        }

        public IActionResult DownloadOptions() => View();

        [HttpPost]
        public IActionResult Download(string format)
        {
            if (!TempData.ContainsKey("FinalData"))
                return RedirectToAction("Index");

            var data = JsonSerializer.Deserialize<List<ExtractedData>>(TempData["FinalData"] as string);
            var fileName = $"ExtractedData_{DateTime.Now:yyyyMMddHHmmss}";

            return format switch
            {
                "csv" => File(GenerateCsv(data), "text/csv", fileName + ".csv"),
                "excel" => File(GenerateExcel(data), "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", fileName + ".xlsx"),
                "pdf" => File(GeneratePdf(data), "application/pdf", fileName + ".pdf"),
                _ => RedirectToAction("Index")
            };
        }

        private async Task<List<ExtractedData>> ExtractDataFromNanonets(string filePath)
        {
            var results = new List<ExtractedData>();

            using var client = new HttpClient();
            var byteArray = Encoding.ASCII.GetBytes(_apiKey + ":");
            client.DefaultRequestHeaders.Authorization =
                new AuthenticationHeaderValue("Basic", Convert.ToBase64String(byteArray));

            using var form = new MultipartFormDataContent();
            form.Add(new StreamContent(System.IO.File.OpenRead(filePath)), "file", Path.GetFileName(filePath));

            var response = await client.PostAsync($"https://app.nanonets.com/api/v2/OCR/Model/{_modelId}/LabelFile/", form);
            var json = await response.Content.ReadAsStringAsync();

            // Rough parsing
            var items = json.Split(new[] { "\"field_name\"", "\"text\"" }, StringSplitOptions.None);
            for (int i = 1; i < items.Length - 1; i += 2)
            {
                string field = ExtractValue(items[i]);
                string value = ExtractValue(items[i + 1]);
                if (!string.IsNullOrEmpty(field))
                    results.Add(new ExtractedData { FieldName = field, Value = value });
            }

            return results;
        }

        private string ExtractValue(string input)
        {
            int start = input.IndexOf(":") + 2;
            int end = input.IndexOf("\"", start);
            if (start > 1 && end > start)
                return input.Substring(start, end - start);
            return string.Empty;
        }

        private byte[] GenerateCsv(List<ExtractedData> data)
        {
            var sb = new StringBuilder();
            sb.AppendLine("FieldName,Value");
            foreach (var d in data)
                sb.AppendLine($"{d.FieldName},{d.Value}");
            return Encoding.UTF8.GetBytes(sb.ToString());
        }

        private byte[] GenerateExcel(List<ExtractedData> data)
        {
            using var wb = new XLWorkbook();
            var ws = wb.Worksheets.Add("ExtractedData");
            ws.Cell(1, 1).Value = "Field Name";
            ws.Cell(1, 2).Value = "Value";
            for (int i = 0; i < data.Count; i++)
            {
                ws.Cell(i + 2, 1).Value = data[i].FieldName;
                ws.Cell(i + 2, 2).Value = data[i].Value;
            }
            using var ms = new MemoryStream();
            wb.SaveAs(ms);
            return ms.ToArray();
        }

        private byte[] GeneratePdf(List<ExtractedData> data)
        {
            var sb = new StringBuilder();
            sb.AppendLine("Extracted Data\n\n");
            foreach (var d in data)
                sb.AppendLine($"{d.FieldName}: {d.Value}");
            return Encoding.UTF8.GetBytes(sb.ToString());
        }
    }
}



-----------




@{
    ViewData["Title"] = "Upload Document";
}

<h2>Upload Document</h2>

<form method="post" enctype="multipart/form-data" asp-action="UploadFile">
    <input type="file" name="file" required />
    <button type="submit">Upload</button>
</form>

@if (ViewBag.ShowProcessButton != null)
{
    <hr />
    <form method="post" asp-action="ProcessFile">
        <input type="hidden" name="fileName" value="@ViewBag.FileName" />
        <button type="submit">Process File</button>
    </form>
}





-----------


@model List<NanonetsExtractor.Models.ExtractedData>

<h2>Edit Extracted Data</h2>

<form method="post" asp-action="ConfirmChanges">
    <table border="1" cellpadding="5">
        <tr><th>Field Name</th><th>Value</th></tr>
        @for (int i = 0; i < Model.Count; i++)
        {
            <tr>
                <td><input type="text" name="[@i].FieldName" value="@Model[i].FieldName" readonly /></td>
                <td><input type="text" name="[@i].Value" value="@Model[i].Value" /></td>
            </tr>
        }
    </table>
    <br />
    <button type="submit">Confirm Changes</button>
</form>




----------



<h2>Download Extracted Report</h2>

<form method="post" asp-action="Download">
    <select name="format" required>
        <option value="pdf">PDF</option>
        <option value="csv">CSV</option>
        <option value="excel">Excel</option>
    </select>
    <button type="submit">Download</button>
</form>


