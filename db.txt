using System;
using System.Configuration;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.Data.Sqlite;

namespace DbToCsvExporter
{
    class Program
    {
        static void Main(string[] args)
        {
            string dbFolderPath = ConfigurationManager.AppSettings["DbFolderPath"];
            string csvFolderPath = ConfigurationManager.AppSettings["CsvFolderPath"];
            string logFile = Path.Combine(dbFolderPath, "exceptions.txt");

            try
            {
                if (string.IsNullOrWhiteSpace(dbFolderPath) || string.IsNullOrWhiteSpace(csvFolderPath))
                {
                    Console.WriteLine("Please set DbFolderPath and CsvFolderPath in App.config.");
                    return;
                }

                Directory.CreateDirectory(csvFolderPath);

                string dbFile = Directory.GetFiles(dbFolderPath, "*.db")
                    .OrderByDescending(f => new FileInfo(f).LastWriteTime)
                    .FirstOrDefault();

                if (dbFile == null)
                {
                    Console.WriteLine("No .db file found in: " + dbFolderPath);
                    return;
                }

                Console.WriteLine("Using DB file: " + dbFile);

                try
                {
                    using (var conn = new SqliteConnection("Data Source=" + dbFile))
                    {
                        conn.Open();

                        using (var tblCmd = conn.CreateCommand())
                        {
                            tblCmd.CommandText = "SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%';";

                            using (var tblReader = tblCmd.ExecuteReader())
                            {
                                var tables = new System.Collections.Generic.List<string>();
                                while (tblReader.Read())
                                {
                                    tables.Add(tblReader.GetString(0));
                                }

                                if (tables.Count == 0)
                                {
                                    Console.WriteLine("No user tables found in DB.");
                                    return;
                                }

                                foreach (var table in tables)
                                {
                                    try
                                    {
                                        ExportTableToCsv_UsingSqlite(conn, table, csvFolderPath, logFile);
                                    }
                                    catch (Exception exTable)
                                    {
                                        string m = $"[{DateTime.Now}] Table '{table}': {exTable}\n";
                                        File.AppendAllText(logFile, m);
                                        Console.WriteLine($"Error exporting table '{table}': {exTable.Message}");
                                    }
                                }
                            }
                        }

                        conn.Close();
                    }

                    Console.WriteLine("All done.");
                }
                catch (Exception ex)
                {
                    File.AppendAllText(logFile, $"[{DateTime.Now}] General DB read error: {ex}\n");
                    Console.WriteLine("Error reading DB: " + ex.Message);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Fatal error: " + ex.Message);
            }
        }

        static void ExportTableToCsv_UsingSqlite(SqliteConnection conn, string tableName, string csvFolderPath, string logFile)
        {
            string safeTable = tableName.Replace("\"", "\"\"");
            string csvFileName = SanitizeFileName(tableName) + ".csv";
            string csvPath = Path.Combine(csvFolderPath, csvFileName);

            using (var cmd = conn.CreateCommand())
            {
                cmd.CommandText = $"SELECT * FROM \"{safeTable}\";";
                using (var reader = cmd.ExecuteReader())
                {
                    using (var writer = new StreamWriter(csvPath, false, Encoding.UTF8))
                    {
                        int cols = reader.FieldCount;

                        // Header
                        for (int i = 0; i < cols; i++)
                        {
                            if (i > 0) writer.Write(",");
                            writer.Write(EscapeCsvField(reader.GetName(i)));
                        }
                        writer.WriteLine();

                        // Rows
                        int rowCount = 0;
                        while (reader.Read())
                        {
                            for (int i = 0; i < cols; i++)
                            {
                                if (i > 0) writer.Write(",");
                                if (reader.IsDBNull(i))
                                {
                                    // empty
                                }
                                else
                                {
                                    var val = reader.GetValue(i);
                                    writer.Write(EscapeCsvField(val != null ? val.ToString() : ""));
                                }
                            }
                            writer.WriteLine();
                            rowCount++;
                        }

                        Console.WriteLine($"Exported {rowCount} rows from '{tableName}' → {csvPath}");
                    }
                }
            }
        }

        static string EscapeCsvField(string s)
        {
            if (s == null) return "";
            bool mustQuote = s.Contains(",") || s.Contains("\"") || s.Contains("\n") || s.Contains("\r");
            if (s.Contains("\"")) s = s.Replace("\"", "\"\"");
            return mustQuote ? $"\"{s}\"" : s;
        }

        static string SanitizeFileName(string name)
        {
            var invalid = Path.GetInvalidFileNameChars();
            var sb = new StringBuilder();
            foreach (var c in name)
            {
                sb.Append(invalid.Contains(c) ? '_' : c);
            }
            return sb.ToString();
        }
    }
}
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
  <appSettings>
    <!-- folder where .db files live -->
    <add key="DbFolderPath" value="C:\Akshat\Assembly\DB\"/>

    <!-- folder where CSV files will be created (will be created automatically) -->
    <add key="CsvFolderPath" value="C:\Akshat\Assembly\CSV\"/>
  </appSettings>
</configuration>



using System;
using System.Collections.Generic;
using System.Configuration;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.Data.Sqlite;

namespace Assembly3DCamera
{
    class Program
    {
        private static Dictionary<string, long> vLastExportedRowId = new Dictionary<string, long>();
        private static Timer oTimer;

        static void Main(string[] args)
        {
            string vDbFolderPath = ConfigurationManager.AppSettings["DbFolderPath"];
            string vCsvFolderPath = ConfigurationManager.AppSettings["CsvFolderPath"];
            string vLogFile = Path.Combine(vDbFolderPath, "exceptions.txt");

            if (string.IsNullOrWhiteSpace(vDbFolderPath) || string.IsNullOrWhiteSpace(vCsvFolderPath))
            {
                Console.WriteLine("Please set DbFolderPath and CsvFolderPath in App.config.");
                return;
            }

            Directory.CreateDirectory(vCsvFolderPath);

            // Run immediately, then every 5 minutes
            oTimer = new Timer(delegate { ExportDbToCsv(vDbFolderPath, vCsvFolderPath, vLogFile); },
                               null, TimeSpan.Zero, TimeSpan.FromMinutes(5));

            Console.WriteLine("Exporter started. Press ENTER to exit...");
            Console.ReadLine();
        }

        static void ExportDbToCsv(string vDbFolderPath, string vCsvFolderPath, string vLogFile)
{
    try
    {
        string vDbFile = Directory.GetFiles(vDbFolderPath, "*.db")
            .OrderByDescending(f => new FileInfo(f).LastWriteTime)
            .FirstOrDefault();

        if (vDbFile == null)
        {
            Console.WriteLine($"[{DateTime.Now}] No .db file found in: " + vDbFolderPath);
            return;
        }

        using (var oConn = new SqliteConnection("Data Source=" + vDbFile))
        {
            oConn.Open();

            using (var oTblCmd = oConn.CreateCommand())
            {
                oTblCmd.CommandText = "SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%';";

                using (var oTblReader = oTblCmd.ExecuteReader())
                {
                    List<string> vTables = new List<string>();
                    while (oTblReader.Read())
                        vTables.Add(oTblReader.GetString(0));

                    foreach (string vTable in vTables)
                    {
                        try
                        {
                            ExportTableToCsv(oConn, vTable, vCsvFolderPath, vLogFile);
                        }
                        catch (Exception exTable)
                        {
                            string vMessage = $"[{DateTime.Now}] Table '{vTable}': {exTable}\n";
                            File.AppendAllText(vLogFile, vMessage);
                        }
                    }
                }
            }
        }

        // ✅ Always print status at the end of each cycle
        Console.WriteLine($"[{DateTime.Now}] Check complete — all tables processed.");
    }
    catch (Exception ex)
    {
        File.AppendAllText(vLogFile, $"[{DateTime.Now}] General DB read error: {ex}\n");
        Console.WriteLine("Error reading DB: " + ex.Message);
    }
}

        static void ExportTableToCsv(SqliteConnection oConn, string vTableName, string vCsvFolderPath, string vLogFile)
        {
            string vSafeTable = vTableName.Replace("\"", "\"\"");
            string vCsvFileName = SanitizeFileName(vTableName) + ".csv";
            string vCsvPath = Path.Combine(vCsvFolderPath, vCsvFileName);

            long vLastRowId = 0;
            if (vLastExportedRowId.ContainsKey(vTableName))
                vLastRowId = vLastExportedRowId[vTableName];

            string vQuery = vLastRowId == 0
                ? $"SELECT ROWID, * FROM \"{vSafeTable}\";"
                : $"SELECT ROWID, * FROM \"{vSafeTable}\" WHERE ROWID > {vLastRowId};";

            using (var oCmd = oConn.CreateCommand())
            {
                oCmd.CommandText = vQuery;
                using (var oReader = oCmd.ExecuteReader())
                {
                    if (!oReader.HasRows) return;

                    using (var oWriter = new StreamWriter(vCsvPath, File.Exists(vCsvPath), Encoding.UTF8))
                    {
                        int vCols = oReader.FieldCount;

                        // Write header if file doesn't exist
                        if (!File.Exists(vCsvPath))
                        {
                            for (int i = 1; i < vCols; i++) // skip ROWID
                            {
                                if (i > 1) oWriter.Write(",");
                                oWriter.Write(EscapeCsvField(oReader.GetName(i)));
                            }
                            oWriter.WriteLine();
                        }

                        long vMaxRowId = vLastRowId;
                        int vRowCount = 0;

                        while (oReader.Read())
                        {
                            long vRowId = oReader.GetInt64(0);
                            vMaxRowId = Math.Max(vMaxRowId, vRowId);

                            for (int i = 1; i < vCols; i++) // skip ROWID
                            {
                                if (i > 1) oWriter.Write(",");
                                if (oReader.IsDBNull(i))
                                    oWriter.Write("");
                                else
                                    oWriter.Write(EscapeCsvField(oReader.GetValue(i).ToString()));
                            }
                            oWriter.WriteLine();
                            vRowCount++;
                        }

                        vLastExportedRowId[vTableName] = vMaxRowId;
                        Console.WriteLine($"[{DateTime.Now}] Exported {vRowCount} new rows from '{vTableName}' → {vCsvPath}");
                    }
                }
            }
        }

        static string EscapeCsvField(string vValue)
        {
            if (vValue == null) return "";
            bool vMustQuote = vValue.Contains(",") || vValue.Contains("\"") || vValue.Contains("\n") || vValue.Contains("\r");
            if (vValue.Contains("\"")) vValue = vValue.Replace("\"", "\"\"");
            return vMustQuote ? $"\"{vValue}\"" : vValue;
        }

        static string SanitizeFileName(string vName)
        {
            var vInvalid = Path.GetInvalidFileNameChars();
            var oSb = new StringBuilder();
            foreach (var vChar in vName)
            {
                oSb.Append(vInvalid.Contains(vChar) ? '_' : vChar);
            }
            return oSb.ToString();
        }
    }
}