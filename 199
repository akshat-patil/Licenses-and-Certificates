using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Microsoft.Data.Sqlite;

namespace Assembly3DCamera
{
    public static class DailyCsvExporter
    {
        public static void ExportDaily(SqliteConnection oConn, string tableName, string baseCsvPath,
                                       string dbKey)
        {
            // --- Build folder structure for today ---
            string todayPath = Path.Combine(
                baseCsvPath,
                DateTime.Now.ToString("yyyy"),
                DateTime.Now.ToString("MM"),
                DateTime.Now.ToString("dd")
            );
            Directory.CreateDirectory(todayPath);

            // --- Today's checkpoint file path ---
            string todayCpFile = Path.Combine(todayPath, $"{DateTime.Now:dd}checkpoints.txt");

            // --- Load today's checkpoints (or bootstrap from yesterday if needed) ---
            Dictionary<string, long> checkpoints = LoadDailyCheckpoints(todayCpFile, todayPath);

            // --- Build checkpoint key ---
            string checkpointKey = dbKey + "|" + tableName;
            long lastRowId = checkpoints.ContainsKey(checkpointKey) ? checkpoints[checkpointKey] : 0;
            long newLast = lastRowId;

            // --- Query only new rows ---
            string query = $"SELECT ROWID, * FROM \"{tableName}\" WHERE ROWID > {lastRowId};";

            using (var cmd = oConn.CreateCommand())
            {
                cmd.CommandText = query;
                using (var reader = cmd.ExecuteReader())
                {
                    if (!reader.HasRows) return;

                    string csvFile = Path.Combine(todayPath, $"{SanitizeFileName(tableName)}.csv");
                    bool writeHeader = !File.Exists(csvFile);

                    using (var writer = new StreamWriter(csvFile, true, Encoding.UTF8))
                    {
                        int cols = reader.FieldCount;

                        // --- Write header once ---
                        if (writeHeader)
                        {
                            for (int i = 1; i < cols; i++)
                            {
                                if (i > 1) writer.Write(",");
                                writer.Write(EscapeCsv(reader.GetName(i)));
                            }
                            writer.WriteLine();
                        }

                        int rowCount = 0;
                        while (reader.Read())
                        {
                            newLast = reader.GetInt64(0);
                            for (int i = 1; i < cols; i++)
                            {
                                if (i > 1) writer.Write(",");
                                writer.Write(reader.IsDBNull(i) ? "" : EscapeCsv(reader.GetValue(i).ToString()));
                            }
                            writer.WriteLine();
                            rowCount++;
                        }

                        if (rowCount > 0)
                        {
                            checkpoints[checkpointKey] = newLast;
                            SaveCheckpoints(todayCpFile, checkpoints);

                            Console.WriteLine($"[{DateTime.Now}] Exported {rowCount} rows from '{tableName}' to {csvFile}");
                        }
                    }
                }
            }
        }

        // --- Load today's checkpoints, or bootstrap from yesterday's file ---
        private static Dictionary<string, long> LoadDailyCheckpoints(string todayCpFile, string todayPath)
        {
            if (File.Exists(todayCpFile))
                return LoadCheckpoints(todayCpFile);

            // Look for yesterday's checkpoints
            var yesterday = DateTime.Now.AddDays(-1);
            string yesterdayPath = Path.Combine(
                Path.GetDirectoryName(Path.GetDirectoryName(Path.GetDirectoryName(todayPath))),
                yesterday.ToString("yyyy"),
                yesterday.ToString("MM"),
                yesterday.ToString("dd")
            );

            string yesterdayCpFile = Path.Combine(yesterdayPath, $"{yesterday:dd}checkpoints.txt");

            if (File.Exists(yesterdayCpFile))
                return LoadCheckpoints(yesterdayCpFile);

            return new Dictionary<string, long>();
        }

        // --- Helper: Load checkpoints file ---
        private static Dictionary<string, long> LoadCheckpoints(string checkpointFile)
        {
            var dict = new Dictionary<string, long>();
            foreach (var line in File.ReadAllLines(checkpointFile))
            {
                if (string.IsNullOrWhiteSpace(line)) continue;
                int idx = line.LastIndexOf('|');
                if (idx <= 0) continue;

                string key = line.Substring(0, idx);
                string valStr = line.Substring(idx + 1);
                if (long.TryParse(valStr, out long val))
                    dict[key] = val;
            }
            return dict;
        }

        // --- Helper: Save checkpoints file ---
        private static void SaveCheckpoints(string checkpointFile, Dictionary<string, long> checkpoints)
        {
            var lines = new List<string>();
            foreach (var kv in checkpoints)
                lines.Add(kv.Key + "|" + kv.Value);
            File.WriteAllLines(checkpointFile, lines);
        }

        // --- CSV helpers ---
        private static string EscapeCsv(string val)
        {
            if (val == null) return "";
            bool mustQuote = val.Contains(",") || val.Contains("\"") || val.Contains("\n") || val.Contains("\r");
            if (val.Contains("\"")) val = val.Replace("\"", "\"\"");
            return mustQuote ? $"\"{val}\"" : val;
        }

        private static string SanitizeFileName(string name)
        {
            var invalid = Path.GetInvalidFileNameChars();
            var sb = new StringBuilder();
            foreach (var c in name)
                sb.Append(invalid.Contains(c) ? '_' : c);
            return sb.ToString();
        }
    }
}