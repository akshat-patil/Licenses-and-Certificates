using System;
using System.Collections.Generic;
using System.Configuration;
using System.IO;
using System.Linq;
using System.Threading;
using Microsoft.Data.Sqlite;

namespace Assembly3DCamera
{
    class Program
    {
        private static Dictionary<string, long> vLastExportedRowId = new Dictionary<string, long>();
        private static Timer oTimer;

        static void Main(string[] args)
        {
            string vDB_CSD = ConfigurationManager.AppSettings["DB_CSD"],
                   vDb_Csv = ConfigurationManager.AppSettings["Db_Csv"],
                   vLogFile = Path.Combine(vDB_CSD, "exceptions.txt"),
                   vCheckpointFile = Path.Combine(vDB_CSD, "data.txt");

            if (string.IsNullOrWhiteSpace(vDB_CSD) || string.IsNullOrWhiteSpace(vDb_Csv))
            {
                Console.WriteLine("Please set DB_CSD and Db_Csv in App.config.");
                return;
            }

            Directory.CreateDirectory(vDb_Csv);
            if (!File.Exists(vLogFile)) File.Create(vLogFile).Dispose();

            vLastExportedRowId = DbToCsv.LoadCheckpoints(vCheckpointFile);

            oTimer = new Timer(delegate { ExportDb(vDB_CSD, vDb_Csv, vLogFile, vCheckpointFile); },
                               null, TimeSpan.Zero, TimeSpan.FromMinutes(5));

            Console.WriteLine("Export started.");
            Console.ReadLine();
        }

        static void ExportDb(string vDB_CSD, string vDb_Csv, string vLogFile, string vCheckpointFile)
        {
            try
            {
                string vDbFile = Directory.GetFiles(vDB_CSD, "*.db")
                                          .OrderByDescending(f => new FileInfo(f).LastWriteTime)
                                          .FirstOrDefault();

                if (vDbFile == null)
                {
                    Console.WriteLine($"[{DateTime.Now}] No .db file found in: " + vDB_CSD);
                    return;
                }

                // If file exists but not accessible (locked/restricted) -> skip this cycle
                if (!IsFileAccessible(vDbFile))
                {
                    File.AppendAllText(vLogFile, $"[{DateTime.Now}] DB file exists but is not accessible: {vDbFile}\n");
                    Console.WriteLine($"[{DateTime.Now}] DB file is locked/not accessible; retrying next cycle.");
                    return;
                }

                string dbKey = Path.GetFileName(vDbFile);

                long fileTicks = File.GetLastWriteTimeUtc(vDbFile).Ticks;
                string fileVerKey = "FILEVER|" + dbKey;
                if (!vLastExportedRowId.ContainsKey(fileVerKey) || vLastExportedRowId[fileVerKey] != fileTicks)
                {
                    var keysToRemove = vLastExportedRowId.Keys
                        .Where(k => k.StartsWith(dbKey + "|") || k.StartsWith("SQL|" + dbKey + "|"))
                        .ToList();

                    foreach (var k in keysToRemove)
                        vLastExportedRowId.Remove(k);

                    vLastExportedRowId[fileVerKey] = fileTicks;
                    Console.WriteLine($"[{DateTime.Now}] Detected new/changed DB file '{dbKey}'. Resetting checkpoints for this file.");
                    File.AppendAllText(vLogFile, $"[{DateTime.Now}] Detected new/changed DB file '{dbKey}'. Resetting checkpoints for this file.\n");
                }

                // Get table list with a short-lived connection (release handle quickly)
                List<string> vTables = new List<string>();
                try
                {
                    using (var oConn = new SqliteConnection("Data Source=" + vDbFile))
                    {
                        oConn.Open();
                        using (var oTblCmd = oConn.CreateCommand())
                        {
                            oTblCmd.CommandText = "SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%';";
                            using (var oTblReader = oTblCmd.ExecuteReader())
                            {
                                while (oTblReader.Read())
                                    vTables.Add(oTblReader.GetString(0));
                            }
                        }
                    } // conn disposed here
                }
                catch (Exception ex)
                {
                    File.AppendAllText(vLogFile, $"[{DateTime.Now}] Error reading table list: {ex}\n");
                    Console.WriteLine($"[{DateTime.Now}] Error reading tables, will retry next cycle.");
                    return;
                }

                // Process each table with its own short-lived connection (opened and disposed per table)
                foreach (string vTable in vTables)
                {
                    try
                    {
                        // Try/catch per table so one failing table doesn't block others
                        using (var tableConn = new SqliteConnection("Data Source=" + vDbFile))
                        {
                            tableConn.Open();

                            // call existing exports (signatures preserved)
                            DbToCsv.mDbToCsv(tableConn, vTable, vDb_Csv, vLogFile, dbKey, vCheckpointFile, vLastExportedRowId);
                            DbToServer.mDbToServer(tableConn, vTable, dbKey, vLogFile, vCheckpointFile, vLastExportedRowId);
                            DailyCsvExporter.ExportDaily(tableConn, vTable, vDb_Csv, dbKey);

                            // after each table run you already call checkpoints inside mDbToCsv, but we keep global write at end too
                        } // connection disposed here
                    }
                    catch (Exception exTable)
                    {
                        string vMessage = $"[{DateTime.Now}] Table '{vTable}': {exTable}\n";
                        File.AppendAllText(vLogFile, vMessage);
                        Console.WriteLine($"[{DateTime.Now}] Error processing table '{vTable}', logged and continuing.");
                    }
                }

                // Save global checkpoints at the end
                DbToCsv.mCheckpoints(vCheckpointFile, vLastExportedRowId);

                // Always show this every cycle (heartbeat)
                Console.WriteLine($"[{DateTime.Now}] Check complete — all tables processed.");
                File.AppendAllText(vLogFile, $"[{DateTime.Now}] Check complete — all tables processed.\n");

                // Combine yesterday's CSVs once per day (safe: CombineYesterdayByLot checks if output exists)
                try
                {
                    CsvCombiner.CombineYesterdayByLot(vDb_Csv);
                }
                catch (Exception exCombine)
                {
                    string vMessage = $"[{DateTime.Now}] CSV Combine failed: {exCombine}\n";
                    File.AppendAllText(vLogFile, vMessage);
                    Console.WriteLine("Error combining CSVs: " + exCombine.Message);
                }
            }
            catch (Exception ex)
            {
                File.AppendAllText(vLogFile, $"[{DateTime.Now}] General DB read error: {ex}\n");
                Console.WriteLine("Error reading DB: " + ex.Message);
            }
        }

        // Quick accessibility check - attempts to open the file for read with shared access.
        // If it fails, we treat the file as currently inaccessible and skip this cycle.
        private static bool IsFileAccessible(string filePath)
        {
            try
            {
                using (FileStream fs = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                {
                    // If you can open it with ReadWrite sharing, treat as accessible.
                    return true;
                }
            }
            catch
            {
                return false;
            }
        }
    }
}
________
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.Data.Sqlite;

namespace Assembly3DCamera
{
    public static class DbToCsv
    {
        static readonly Dictionary<string, string> ColumnMappings = new Dictionary<string, string>
        {
            { "InspectResult", "Detection_result" },
            { "TrigType", "Trigger_mode" },
            { "InspectTime", "Detection_time" },
            { "Product", "Product_name" }
        };

        public static Dictionary<string, long> LoadCheckpoints(string checkpointFile)
        {
            var dict = new Dictionary<string, long>();
            if (!File.Exists(checkpointFile)) return dict;

            foreach (var rawLine in File.ReadAllLines(checkpointFile))
            {
                var line = rawLine.Trim();
                if (string.IsNullOrEmpty(line)) continue;

                int lastPipe = line.LastIndexOf('|');
                if (lastPipe <= 0) continue;

                string key = line.Substring(0, lastPipe);
                string valStr = line.Substring(lastPipe + 1);

                if (long.TryParse(valStr, out long val))
                    dict[key] = val;
            }
            return dict;
        }

        public static void mCheckpoints(string checkpointFile, Dictionary<string, long> checkpoints)
        {
            var lines = checkpoints.Select(kv => kv.Key + "|" + kv.Value);
            File.WriteAllLines(checkpointFile, lines);
        }

        public static void mDbToCsv(SqliteConnection oConn, string vTableName, string vCsvFolderPath,
                                            string vLogFile, string dbKey, string vCheckpointFile,
                                            Dictionary<string, long> checkpoints)
        {
            string vSafeTable = vTableName.Replace("\"", "\"\"");
            string checkpointKey = "File name: " + dbKey + ", " + "Table name: " + vTableName;
            long vLastRowId = checkpoints.ContainsKey(checkpointKey) ? checkpoints[checkpointKey] : 0;

            string vQuery = $"SELECT ROWID, * FROM \"{vSafeTable}\" WHERE ROWID > {vLastRowId};";

            using (var oCmd = oConn.CreateCommand())
            {
                oCmd.CommandText = vQuery;
                using (var oReader = oCmd.ExecuteReader())
                {
                    if (!oReader.HasRows) return;

                    string vCsvFileName = $"{mFileName(vTableName)}.csv";
                    string vCsvPath = Path.Combine(vCsvFolderPath, vCsvFileName);
                    bool fileExists = File.Exists(vCsvPath);

                    using (var oWriter = new StreamWriter(vCsvPath, true, Encoding.UTF8))
                    {
                        int vCols = oReader.FieldCount;
                        if (!fileExists)
                        {
                            for (int i = 1; i < vCols; i++)
                            {
                                if (i > 1) oWriter.Write(",");

                                string originalName = oReader.GetName(i);
                                string mappedName = ColumnMappings.ContainsKey(originalName) ? ColumnMappings[originalName] : originalName;

                                oWriter.Write(mCsvFileFormat(mappedName));
                            }
                            oWriter.WriteLine();
                        }

                        long vMaxRowId = vLastRowId;
                        int vRowCount = 0;
                        while (oReader.Read())
                        {
                            long vRowId = oReader.GetInt64(0);
                            vMaxRowId = Math.Max(vMaxRowId, vRowId);
                            for (int i = 1; i < vCols; i++)
                            {
                                if (i > 1) oWriter.Write(",");
                                oWriter.Write(oReader.IsDBNull(i) ? "" : mCsvFileFormat(oReader.GetValue(i).ToString()));
                            }
                            oWriter.WriteLine();
                            vRowCount++;
                        }

                        checkpoints[checkpointKey] = vMaxRowId;
                        Console.WriteLine($"[{DateTime.Now}] Exported {vRowCount} new rows from '{vTableName}' to {vCsvPath}");

                        if (vRowCount > 0)
                        {
                            string logEntry = $"{DateTime.Now}: {vRowCount} new entries came in table {vTableName}\n";
                            File.AppendAllText(vCheckpointFile, logEntry);
                        }
                    }
                }
            }
        }

        private static string mCsvFileFormat(string vValue)
        {
            if (vValue == null) return "";
            bool vMustQuote = vValue.Contains(",") || vValue.Contains("\"") || vValue.Contains("\n") || vValue.Contains("\r");
            if (vValue.Contains("\"")) vValue = vValue.Replace("\"", "\"\"");
            return vMustQuote ? $"\"{vValue}\"" : vValue;
        }

        private static string mFileName(string vName)
        {
            var vInvalid = Path.GetInvalidFileNameChars();
            var oSb = new StringBuilder();
            foreach (var vChar in vName)
                oSb.Append(vInvalid.Contains(vChar) ? '_' : vChar);
            return oSb.ToString();
        }
    }
}
_______
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data.SqlClient;
using Microsoft.Data.Sqlite;
using System.IO;

namespace Assembly3DCamera
{
    public static class DbToServer
    {
        public static void mDbToServer(SqliteConnection oConn, string vTableName, string dbKey,
                                    string vLogFile, string vCheckpointFile,
                                    Dictionary<string, long> checkpoints)
        {
            string checkpointKey = "SQL|" + dbKey + "|" + vTableName;
            long vLastRowId = checkpoints.ContainsKey(checkpointKey) ? checkpoints[checkpointKey] : 0;

            string vQuery = $"SELECT ROWID, * FROM \"{vTableName}\" WHERE ROWID > {vLastRowId};";

            using (var oCmd = oConn.CreateCommand())
            {
                oCmd.CommandText = vQuery;
                using (var oReader = oCmd.ExecuteReader())
                {
                    if (!oReader.HasRows) return;

                    string sqlTableName = vTableName;
                    string connStr = ConfigurationManager.AppSettings["SqlServerConn"];

                    using (var sqlConn = new SqlConnection(connStr))
                    {
                        sqlConn.Open();
                        CreateSqlTable(sqlConn, oReader, sqlTableName);

                        long vMaxRowId = vLastRowId;
                        int vRowCount = 0;
                        while (oReader.Read())
                        {
                            long vRowId = oReader.GetInt64(0);
                            vMaxRowId = Math.Max(vMaxRowId, vRowId);
                            InsertRow(sqlConn, sqlTableName, oReader);
                            vRowCount++;
                        }

                        checkpoints[checkpointKey] = vMaxRowId;
                        Console.WriteLine($"[{DateTime.Now}] Exported {vRowCount} rows to SQL Server table {sqlTableName}");

                        if (vRowCount > 0)
                        {
                            string logEntry = $"{DateTime.Now}: {vRowCount} new entries came in table {vTableName}\n";
                            File.AppendAllText(vCheckpointFile, logEntry);
                        }
                    }
                }
            }
        }

        private static void CreateSqlTable(SqlConnection sqlConn, SqliteDataReader reader, string sqlTableName)
        {
            using (var cmd = sqlConn.CreateCommand())
            {
                List<string> cols = new List<string>();
                for (int i = 1; i < reader.FieldCount; i++)
                {
                    string colName = reader.GetName(i);
                    cols.Add($"[{colName}] NVARCHAR(MAX)");
                }

                cmd.CommandText = $"IF OBJECT_ID('{sqlTableName}', 'U') IS NULL " +
                                  $"CREATE TABLE [{sqlTableName}] ({string.Join(",", cols)});";
                cmd.ExecuteNonQuery();
            }
        }

        private static void InsertRow(SqlConnection sqlConn, string sqlTableName, SqliteDataReader reader)
        {
            List<string> colNames = new List<string>();
            List<string> colParams = new List<string>();
            var values = new List<SqlParameter>();

            for (int i = 1; i < reader.FieldCount; i++)
            {
                string colName = reader.GetName(i);
                colNames.Add($"[{colName}]");
                colParams.Add($"@p{i}");
                object val = reader.IsDBNull(i) ? DBNull.Value : reader.GetValue(i);
                values.Add(new SqlParameter($"@p{i}", val));
            }

            string sql = $"INSERT INTO [{sqlTableName}] ({string.Join(",", colNames)}) VALUES ({string.Join(",", colParams)});";
            using (var cmd = new SqlCommand(sql, sqlConn))
            {
                cmd.Parameters.AddRange(values.ToArray());
                cmd.ExecuteNonQuery();
            }
        }
    }
}
__________
using Microsoft.Data.Sqlite;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace Assembly3DCamera
{
    public static class DailyCsvExporter
    {
        public static void ExportDaily(SqliteConnection oConn, string tableName, string baseCsvPath,
                                       string dbKey)
        {
            string todayPath = Path.Combine(
                baseCsvPath,
                DateTime.Now.ToString("yyyy"),
                DateTime.Now.ToString("MM"),
                DateTime.Now.ToString("dd")
            );
            Directory.CreateDirectory(todayPath);

            string todayCpFile = Path.Combine(todayPath, $"{DateTime.Now:dd}checkpoints.txt");

            Dictionary<string, long> checkpoints = LoadDailyCheckpoints(todayCpFile, todayPath);

            string checkpointKey = dbKey + "|" + tableName;
            long lastRowId = checkpoints.ContainsKey(checkpointKey) ? checkpoints[checkpointKey] : 0;
            long newLast = lastRowId;

            string query = $"SELECT ROWID, * FROM \"{tableName}\" WHERE ROWID > {lastRowId};";

            using (var cmd = oConn.CreateCommand())
            {
                cmd.CommandText = query;
                using (var reader = cmd.ExecuteReader())
                {
                    if (!reader.HasRows) return;

                    string csvFile = Path.Combine(todayPath, $"{SanitizeFileName(tableName)}.csv");
                    bool writeHeader = !File.Exists(csvFile);

                    using (var writer = new StreamWriter(csvFile, true, Encoding.UTF8))
                    {
                        int cols = reader.FieldCount;

                        if (writeHeader)
                        {
                            for (int i = 1; i < cols; i++)
                            {
                                if (i > 1) writer.Write(",");
                                writer.Write(EscapeCsv(reader.GetName(i)));
                            }
                            writer.WriteLine();
                        }

                        int rowCount = 0;
                        while (reader.Read())
                        {
                            newLast = reader.GetInt64(0);
                            for (int i = 1; i < cols; i++)
                            {
                                if (i > 1) writer.Write(",");
                                writer.Write(reader.IsDBNull(i) ? "" : EscapeCsv(reader.GetValue(i).ToString()));
                            }
                            writer.WriteLine();
                            rowCount++;
                        }

                        if (rowCount > 0)
                        {
                            checkpoints[checkpointKey] = newLast;
                            SaveCheckpoints(todayCpFile, checkpoints);

                            Console.WriteLine($"[{DateTime.Now}] Exported {rowCount} rows from '{tableName}' to {csvFile}");
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Loads today's checkpoints, or if missing, searches backwards until it finds the most recent available file.
        /// </summary>
        private static Dictionary<string, long> LoadDailyCheckpoints(string todayCpFile, string todayPath)
        {
            if (File.Exists(todayCpFile))
                return LoadCheckpoints(todayCpFile);

            DateTime probeDay = DateTime.Now.AddDays(-1);

            // search back until found, with a safe lower bound
            while (probeDay.Year >= 2000)
            {
                string probePath = Path.Combine(
                    Path.GetDirectoryName(Path.GetDirectoryName(Path.GetDirectoryName(todayPath))),
                    probeDay.ToString("yyyy"),
                    probeDay.ToString("MM"),
                    probeDay.ToString("dd")
                );

                string probeCpFile = Path.Combine(probePath, $"{probeDay:dd}checkpoints.txt");

                if (File.Exists(probeCpFile))
                {
                    Console.WriteLine($"[{DateTime.Now}] No checkpoints for today, using last available from {probeDay:yyyy-MM-dd}");
                    return LoadCheckpoints(probeCpFile);
                }

                probeDay = probeDay.AddDays(-1);
            }

            return new Dictionary<string, long>();
        }

        private static Dictionary<string, long> LoadCheckpoints(string checkpointFile)
        {
            var dict = new Dictionary<string, long>();
            foreach (var line in File.ReadAllLines(checkpointFile))
            {
                if (string.IsNullOrWhiteSpace(line)) continue;
                int idx = line.LastIndexOf('|');
                if (idx <= 0) continue;

                string key = line.Substring(0, idx);
                string valStr = line.Substring(idx + 1);
                if (long.TryParse(valStr, out long val))
                    dict[key] = val;
            }
            return dict;
        }

        private static void SaveCheckpoints(string checkpointFile, Dictionary<string, long> checkpoints)
        {
            var lines = new List<string>();
            foreach (var kv in checkpoints)
                lines.Add(kv.Key + "|" + kv.Value);
            File.WriteAllLines(checkpointFile, lines);
        }

        private static string EscapeCsv(string val)
        {
            if (val == null) return "";
            bool mustQuote = val.Contains(",") || val.Contains("\"") || val.Contains("\n") || val.Contains("\r");
            if (val.Contains("\"")) val = val.Replace("\"", "\"\"");
            return mustQuote ? $"\"{val}\"" : val;
        }

        private static string SanitizeFileName(string name)
        {
            var invalid = Path.GetInvalidFileNameChars();
            var sb = new StringBuilder();
            foreach (var c in name)
                sb.Append(invalid.Contains(c) ? '_' : c);
            return sb.ToString();
        }
    }
}
__________
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace Assembly3DCamera
{
    public static class CsvCombiner
    {
        public static void CombineYesterdayByLot(string baseCsvPath)
        {
            DateTime yesterday = DateTime.Now.AddDays(-1);
            string folderPath = Path.Combine(
                baseCsvPath,
                yesterday.ToString("yyyy"),
                yesterday.ToString("MM"),
                yesterday.ToString("dd")
            );

            if (!Directory.Exists(folderPath))
            {
                Console.WriteLine($"[{DateTime.Now}] Yesterday folder not found: {folderPath}");
                return;
            }

            string outputFileName = yesterday.ToString("ddMMyyyy") + ".csv";
            string combinedFile = Path.Combine(folderPath, outputFileName);

            if (File.Exists(combinedFile))
            {
                Console.WriteLine($"[{DateTime.Now}] Combined file already exists: {combinedFile}");
                return;
            }

            var csvFiles = Directory.GetFiles(folderPath, "*.csv")
                                    .Where(f => !f.EndsWith(outputFileName))
                                    .ToList();

            if (csvFiles.Count == 0)
            {
                Console.WriteLine($"[{DateTime.Now}] No CSV files to combine in {folderPath}");
                return;
            }

            List<string> headers = null;
            var rows = new List<string[]>();

            foreach (var file in csvFiles)
            {
                var lines = File.ReadAllLines(file);
                if (lines.Length == 0) continue;

                var fileHeaders = lines[0].Split(',');
                if (headers == null)
                {
                    headers = fileHeaders.ToList();
                }

                for (int i = 1; i < lines.Length; i++)
                {
                    if (string.IsNullOrWhiteSpace(lines[i])) continue;
                    rows.Add(lines[i].Split(','));
                }
            }

            if (headers == null || rows.Count == 0)
            {
                Console.WriteLine($"[{DateTime.Now}] No valid rows found in {folderPath}");
                return;
            }

            int lotIndex = headers.IndexOf("LOT");
            if (lotIndex == -1)
            {
                Console.WriteLine($"[{DateTime.Now}] LOT column not found, cannot combine.");
                return;
            }

            var sortedRows = rows.OrderBy(r => r[lotIndex]).ToList();

            using (var writer = new StreamWriter(combinedFile))
            {
                writer.WriteLine(string.Join(",", headers));
                foreach (var row in sortedRows)
                {
                    writer.WriteLine(string.Join(",", row));
                }
            }

            Console.WriteLine($"[{DateTime.Now}] Combined CSV created: {combinedFile}");
        }
    }
}
_________